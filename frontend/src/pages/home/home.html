
<div class="@container bg-body flex flex-col gap-2 p-4 items-center mx-auto w-screen h-screen relative" id="animation_container">
<!-- 
  <h1 class="text-white arcade-font font-[500] text-5xl led-font">TRASCENDENCE</h1>
  <h1 class="text-white arcade-font font-[500] text-5xl digital-font">TRASCENDENCE</h1>
  <h1 class="text-white arcade-font font-[500] text-5xl digital-b-font">TRASCENDENCE</h1> -->
  <h1 class="text-white arcade-font font-[900] text-7xl rushblade-font neon-sign pt-20 z-2">TRASCENDENCE</h1>
  
  <div class="flex gap-2 h-full items-center justify-center w-screen z-2">

    <div class="flex justify-center w-[40%] h-[40%]">
        <button class="text-white w-full h-full bg-c-400 text-center identification block" id="playButton">
          <div class="flex flex-col justify-center f-full h-full">
            <h5 class="text-5xl">{{homepage.play}}</h5>
          </div>
        </button>
        <a href="#/login" class="text-white w-full h-full bg-c-600 text-center login block">
          <div class="flex flex-col justify-center f-full h-full">
            <h5 class="text-5xl">{{homepage.login}}</h5>
          </div>
        </a>
    </div>

    <!-- <button type="button" id="logoutButton" class="bg-red-600 text-white px-4 py-2 rounded-md w-full max-w-50">Logout</button> -->

  </div>

</div>


<div class="ball" id="ball"></div>
<script>
  class BouncingBall {
      constructor() {
          this.ball = document.getElementById('ball');
          this.container = document.getElementById('animation_container');
          
          // Ball properties
          this.x = 50;
          this.y = 50;
          this.vx = 3; // velocity in x direction
          this.vy = 2; // velocity in y direction
          this.ballSize = 40;
          
          // Animation state
          this.isRunning = false;
          this.animationId = null;
          
          this.updatePosition();
      }
      
      updatePosition() {
          this.ball.style.left = this.x + 'px';
          this.ball.style.top = this.y + 'px';
      }
      
      checkCollisions() {
          const containerWidth = this.container.clientWidth;
          const containerHeight = this.container.clientHeight;
          
          // Check horizontal boundaries
          if (this.x <= 0 || this.x >= containerWidth - this.ballSize) {
              this.vx = -this.vx; // Reverse horizontal direction
              
              // Keep ball within bounds
              if (this.x <= 0) this.x = 0;
              if (this.x >= containerWidth - this.ballSize) {
                  this.x = containerWidth - this.ballSize;
              }
          }
          
          // Check vertical boundaries
          if (this.y <= 0 || this.y >= containerHeight - this.ballSize) {
              this.vy = -this.vy; // Reverse vertical direction
              
              // Keep ball within bounds
              if (this.y <= 0) this.y = 0;
              if (this.y >= containerHeight - this.ballSize) {
                  this.y = containerHeight - this.ballSize;
              }
          }
      }
      
      animate() {
          if (!this.isRunning) return;
          
          // Update position
          this.x += this.vx;
          this.y += this.vy;
          
          // Check for collisions and bounce
          this.checkCollisions();
          
          // Update visual position
          this.updatePosition();
          
          // Continue animation
          this.animationId = requestAnimationFrame(() => this.animate());
      }
      
      start() {
          if (!this.isRunning) {
              this.isRunning = true;
              this.animate();
          }
      }
      
      reset() {
          this.stop();
          this.x = 50;
          this.y = 50;
          this.vx = 3;
          this.vy = 2;
          this.updatePosition();
      }
  }

  window.BouncingBall = BouncingBall;
  
  function resetBall() {
      bouncingBall.reset();
  }
  
  // Handle window resize
  window.addEventListener('resize', () => {
      // Ball will automatically adjust to new boundaries on next collision
  });

  function initializeBall() {
    console.log("Animation started")
      const ballElement = document.getElementById('ball');
      if (ballElement) {
          const bouncingBall = new BouncingBall();
          bouncingBall.start();
          
          console.log("Animation started if")
          // Make available globally for external control
          window.bouncingBallInstance = bouncingBall;
      } else {
          // If element not found, try again in a bit
          console.log("Animation started else")
          setTimeout(initializeBall, 100);
      }
  }
  
  // Start initialization after a short delay
//   setTimeout(initializeBall, 200);
    initializeBall();

</script>